# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/01_eda.ipynb (unless otherwise specified).

__all__ = ['get_kaggle_dataset', 'pathFromCompetition', 'confirm', 'download_and_log', 'setup']

# Cell
import warnings
warnings.filterwarnings('ignore')
from dotenv import load_dotenv
# https://technowhisp.com/kaggle-api-python-documentation/
from kaggle.api.kaggle_api_extended import KaggleApi
from fastai.vision.all import *
import wandb
import os

# Cell
def get_kaggle_dataset(competition):
    """ Download and extract kaggle competition dataset to fastai data folder and return path to files.
    get_kaggle_dataset(string) -> Path
    args:
        competition: string containing competition name in Kaggle
    returns:
        path to local competition data"""
    config = Config()
    zipdest = Path(config.d['archive_path'])
    zipname = Path(config.d['archive_path']+'/'+competition+'.zip')
    if not zipname.exists():
        print (f'${zipname} does not exist.')
        try:
            k.competition_download_files(competition, path=zipdest)
        except:
            raise Exception(f'No competition {competition} found at Kaggle.')
    print('Downloading....')
    dest = Path(config.d['data_path']+'/'+competition+'/')
    if not dest.exists():
        print (f'${dest} does not exist.  Extracting...')
        file_extract(zipname, dest=dest)
        files = os.listdir(dest)
        for f in files:
            if f.split('.')[-1]=='zip':
                print(dest/f)
                file_extract(dest/f)
                os.remove(dest/f)
    return dest

# Cell
def pathFromCompetition(competition):
    """Returns path to local competition files.
    args:
    competition: string containing name of competition"""
    config = Config()
    ret =  Path(config.d['data_path']+'/'+competition+'/')
    if not ret.exists(): raise Exception('Please download the competition data first.')
    return ret

# Cell
def confirm(msg=""):
    """
    Ask user to enter Y or N (case-insensitive).
    :return: True if the answer is Y.
    :rtype: bool
    """
    answer = ""
    if not msg: msg = "OK to continue"
    while answer not in ["y", "n"]:
        answer = input(msg+" [Y/N]? ").lower()
    return answer == "y"

# Cell
def download_and_log(competition, entity=None):
    """ Start a Run for data download at WandB, download competition data and log data reference in local machine as an Artifact at WandB.
    args:
        competition: string containing competition name
    returns:
        Path to competition data
    """
    try:
        p = pathFromCompetition(competition)
        if not confirm(f'Data for competition found at {p}\n Force new download '): return p
    except: pass
    try:
        k.competition_list_files(competition)
    except:
        print (f'No competition {competition} found at Kaggle.')
        return None
    # üöÄ start a run, with a type to label it and a project it can call home
    wandb.init()
    with wandb.init(project=competition, entity=entity, job_type="download-data") as run:
        path = get_kaggle_dataset(competition)
        sizes = {}
        raw_data = wandb.Artifact(
            competition, type="dataset",
            description=f'Raw {competition} dataset.',
            metadata={"source": "Kaggle"})
        for b, ds, _ in os.walk(path):
            for d in ds:
                files = get_image_files(b+'/'+d)
                sizes[d] = len(files)
                for f in tqdm(files):
                    raw_data.add_reference('file://'+str(f))
        raw_data.metadata['sizes']=sizes
        # ‚úçÔ∏è Save the artifact to W&B.
        run.log_artifact(raw_data)
        return path

# Cell
def setup(competition, entity=None):
    """ Returns Path to local competition files, download and log data if needed.
    """
    # load_dotenv()
    k = KaggleApi()
    k.authenticate()
    try:
        k.competition_list_files(competition)
    except:
        print (f'No competition {competition} found.')
        return None
    try:
        p = pathFromCompetition(competition)
    except:
        if not confirm(f'Download data for {competition} '): return None
        return download_and_log(competition, entity)
    return p

# Cell
from .data import *
from fastai.vision.all import *
from fastai.medical.imaging import *
import matplotlib.pyplot as plt
import seaborn as sns
from tqdm import tqdm
import wandb
assert torch.cuda.is_available()